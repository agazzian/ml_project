#!/usr/bin/python

import EnzClass as EC
import EnzLoad as EL
import GraphOut as GO
import random
from igraph import *


def randnet(G):
	"""
	Algorithm for the randomization of the edges of the graph G
	This algorithm mantains the COLORED in- and out-degree of 
	each of the vertices in the network. It returns the edgelist and
	the corresponding colorlist of the new graph (eoutlst and coutlst respectively).
	"""
	
	#initializationo of the lists
	elst = G.get_edgelist()
	clst = G.es['color'][:]
	cdic = {}
	for i,c in enumerate(clst):
		cdic[c]=i
	lst1 = [[]]*len(key)
	for i,e in enumerate(elst):
		lst1[cdic[clst[i]]].append([e[0],e[1]])
		
	#randomization procedure
	for i in range(random.randrange(100,200)):
		cid = cdic[random.choice(clst)] #random choice weighted by the frequency of each color
		e1id = random.randrange(0,len(lst1[cid])) #random choice of edge with that color
		e2id = random.randrange(0,len(lst1[cid]))
		extop = random.randrange(0,2)#random choice of top/bottom
		ttemp = lst1[cid][e1id][extop]
		lst1[cid][e1id][extop] = lst1[cid][e2id][extop]
		lst1[cid][e2id][extop] = ttemp
	
	coutlst = []
	eoutlst	= []
	for i in range(len(lst1)):
		c = clst[i]
		for e in lst1[i]:
			coutlst.append(c)
			eoutlst.append((e[0],e[1]))

	return [eoutlst,coutlst]


def generate_graph_fca(organism):
	"""
	creates a graph object G corresponding to the graph given by the adjacency 
	matrix stored in ./organism/"organism"/fcagraph.txt generated by the fca of barabasi
	"""
	with open('./organisms/'+organism+'/'+'fcagraph.txt','r') as gfile:
		rnamelst = [] 
		enamelst = []
		clst = []
		for line in gfile:
			e = line.strip().split('\t')
			for rname in e[0:2]:
				if rname not in rnamelst:
					rnamelst.append(rname)
			enamelst.append((e[0],e[1]))
			clst.append(e[2])
			
		G = igraph.Graph(0,directed=True)
		G.add_vertices(rnamelst)
		G.add_edges(enamelst)
		G.es['color'] = clst
	
	return G
		

def stoich(dic,organism):
	"""saves the results of the 'stoich' function in the dic class"""

	[smat,clst,rlst,revlst] = dic.stoichmat()

	with open('./results/'+organism+'/fca/smat.log','w') as smatout:
		for l1 in smat:
			for l2 in l1:
				smatout.write(str(l2)+'\t')
			smatout.write('\n')

	with open('./results/'+organism+'/fca/clst.log','w') as clstout:
		for l1 in clst:
			clstout.write(l1+'\n')
		
	with open('./results/'+organism+'/fca/rlst.log','w') as rlstout:
		for l1 in rlst:
			rlstout.write(l1+'\n')
			
	with open('./results/'+organism+'/fca/revlst.log','w') as revlstout:
		for l1 in revlst:
			revlstout.write(str(int(l1))+'\n')
		
	print 'Stoichiometric analysis completed'


# irreversible reactions
# non stabilizing reactions
# resting connected to hubs
def FbReg(dic,organism):
	counter1 = 0
	counter2 = 0
	for e in dic.elst:
		if e.stab() == True:
			counter1 += 1
			if e.competitive == 'c':
				counter2 += 1
	print('\nNumber of competitive regulations:\t'+str(counter2)+'\tout of '+str(counter1)+' stabilizing reactions\n')

	print('\nNumber of regulations with unknown nature: '+str(len([e.name for e in dic.elst if e.activation == None]))+' out of '+str(len(dic.elst))+'\n')



def DoubleReg(dic,organism):
	""" lists all reactions that have more than one regulator in the output file"""
	with open('./results/'+organism+'/logfiles/logmeta.log','w') as out:
		counter1 = 0
		counter2 = 0
		for r in dic.rlst:
			if len(r.elst) >= 1:
				counter1 += 1
			if len(r.elst) >= 2: 
				out.write('\nReaction name:\t'+r.name+'\t(Reversible: '+str(r.reversible)+', common name: '+','.join(map(str,r.commname))+')\nIN-PWY: '+','.join(map(str,r.inpath))+'\nIN/OUT:\t'+str(r.innames)+'\t'+str(r.outnames)+'\n')
				counter2 += 1
				for e in r.elst:
					out.write(str(e.activation)+'\t'+e.cs[0].name+'\n')
		out.write('\n\nTOTAL = '+str(counter2))
		print('\n% of reactions controlled by 2 or more compounds:\t'+str(counter2)+' out of '+str(counter1)+'catalyzed reactions\n\t\t\t\t\t\t\t'+str(counter2)+' out of '+str(len(dic.rlst))+'general reactions\n')

def HubAnalysis(dic,organism):
	"""
	This function performs statistics on the substrate reaction graph from the point of view of HUBS. In particular it performs the following tasks:
	- it counts the number of valid regulations (irreversible and non-feedback) and those that are regulated by hub nodes among them.
	- it counts (terminal output) and lists (text file output) the set of reactions that are catalyzed by a hub node, indicating if the catalysis is active or passive and wether it is stabilizing or not,
	- it counts the number of irreversible reactions catalyzed by hub nodes,
	- generates a graph of the HUB nodes, describing their interaction.
	"""
	HUB = ['ATP','ADP','AMP','NADP','NADPH','NAD','NADH','ACETYL-COA','CA+2','MG+2','Pi','PPI','CO-A','AMMONIUM']
	counter1 = 0
	counter2 = 0
	with open('./results/'+organism+'/logfiles/HUBcontrol.log','w') as out:
		out.write('This file lists all valid regulations (irreversible and non-feedback) that are not controlled by HUBS')
		for e in dic.elst:
			if e.rct.reversible != True:
				if e.activation != False or len([p.name for p in dic.plst if e.cs[0].name in p.totgraph.vs['name'][:] and e.rct.name in p.totgraph.vs['name'][:] and p.totgraph.are_connected(e.rct.name,e.cs[0].name)])!=0:
					counter1 += 1	
					if intersection(e.rct.innames,HUB) != [] and intersection(e.rct.outnames,HUB) != []:
						counter2 += 1
					else:
						out.write('\nENAME:\t'+e.name+'\nRNAME:\t'+e.rct.name+'\nINPATH:\t'+', '.join([i for i in e.rct.inpath])+'\nACT:\t'+', '.join([c.name for c in e.cs])+'\n')
		print('\nNumber of valid regulations (irreversible and non-feedback) catalyzed by hubs:\t'+str(counter2)+'\tout of '+str(counter1)+' valid regulations\n')

	contcounter = 0
	hubcontcounter = 0
	tpluscount = 0
	tminuscount = 0
	flowregcounter = 0
	with open('./results/'+organism+'/logfiles/HUBirrev.log','w') as out1:
		with open('./results/'+organism+'/logfiles/HUBStat.log','w') as out2:
			out1.write('# This file contains a list of all reactions that are irreversible and use a hub as driving force\n# Structure of file:\tREACTION-NAME\tINNAMES\tOUTNAMES\n\n')
			out2.write('# This file contains a list of all reactions that are regulated by hubs, indicating if the regulation is stabilizing or destabilizing\n\n')
			for r in dic.rlst:
				# hubs as substrates	
				if intersection(r.innames,HUB) != [] and intersection(r.outnames,HUB) != [] and r.reversible == False:
					out1.write(str(r.name)+'\t'+str(r.innames)+'\t'+str(r.outnames)+'\n')
					flowregcounter += 1
				# control through hubs
				if len(r.elst) != 0:
					contcounter += 1
					pluscount = 0
					minuscount = 0
					hubelst = [e for e in r.elst if intersection([c.name for c in e.cs],HUB) != []]
					if len(hubelst) != 0:
						hubcontcounter += 1
						out2.write('\nReaction name:\t'+r.name+'\t(Reversible: '+str(r.reversible)+', common name: '+','.join(map(str,r.commname))+')\nIN-PWY: '+','.join(map(str,r.inpath))+'\nIN/OUT:\t'+str(r.innames)+'\t'+str(r.outnames)+'\n')
						for e in hubelst:
							if e.stab() in [True,False]:
								out2.write('Act: '+str(e.activation)+'\tStab: '+str(e.stab)+'\t'+','.join(map(str,[c.name for c in e.cs]))+'\n')
								if e.stab() == True:
									pluscount += 1
								else:
									minuscount += 1
						out2.write('TOTAL [#stabilizing,#destabilizing]:\t'+str([pluscount,minuscount]))
						tpluscount += pluscount
						tminuscount += minuscount
	print('\n# of HUB-driven irreversible reactions: \t'+str(flowregcounter)+'\tout of\t'+str(len([1 for r in dic.rlst if r.reversible == False]))+' irreversible reactions\n')
	print('\n# of HUB-regulated reactions:\t'+str(hubcontcounter)+'\tout of\t'+str(contcounter)+' regulated reactions\n\t\t\tstabilizing:\t'+str(tpluscount)+'\n\t\t\tdestabilizing:\t'+str(tminuscount))

	#creation of the HUB-graph
	gr = Graph(0, directed = True)
	gr.add_vertices(HUB)
	for r in dic.rlst:
		if intersection(r.innames,HUB) != [] or intersection(r.outnames,HUB) != []:
			gr.add_vertices([r.name])
			for h in intersection(r.innames,HUB):
				gr.add_edges([(h,r.name)])
			for h in intersection(r.outnames,HUB):
				gr.add_edges([(r.name,h)])
			if r.reversible == True:
				for h in intersection(r.innames,HUB):
					gr.add_edges([(r.name,h)])
				for h in intersection(r.outnames,HUB):
					gr.add_edges([(h,r.name)])
	GO.write_hub_gml(gr,[e for e in dic.elst if intersection([c.name for c in e.cs],HUB) != []],'./results/'+organism+'/graphs/HUB_rct_graph.gml')

	#creation of the pathway HUB-graph
	#coupling di reazioni attraverso pathways, ma come? il problema e che reazioni diverse devono essere accoppiate
	#guardare grafo senza hub

	#this graph has as nodes the hubs and the pathways connecting them.
	#the connection pathways, that can be seen as reactions, are chosen if in at least one reaction in the pathway there is an intersection between the principal in elements and the hublist AND an intersection between the principal out elements and the hubs (in practice, if there is a reaction that is hub driven).
	gp = Graph(0, directed = True)
	gp.add_vertices(HUB)
	for p in dic.plst:
		inlst = []
		outlst = []
		rlst = []
		if p.substrates != [] and p.byproducts != []:
			inlst = intersection([c.name for c in p.substrates if c != None],HUB)
			outlst = intersection([c.name for c in p.byproducts if c != None],HUB)
		if intersection(inlst,HUB) != [] and intersection(outlst,HUB) != []:	
			print p.name
			print inlst
			print outlst
			print '\n'		
			gp.add_vertices([p.name])
			for h in inlst:
				gp.add_edges([(h,p.name)])
			for h in outlst:
				gp.add_edges([(p.name,h)])
	GO.write_hub_gml(gp,[e for e in dic.elst if intersection([c.name for c in e.cs],HUB) != []],'./results/'+organism+'/graphs/HUB_path_graph.gml')

	#the connection pathways, that can be seen as reactions, are chosen if in at least one reaction in the pathway there is an intersection between the principal in elements and the hublist OR an intersection between the principal out elements and the hubs (so these are pathways that couple weakly hubs).
	gp = Graph(0, directed = True)
	gp.add_vertices(HUB)
	for p in dic.plst:
		inlst = []
		outlst = []
		rlst = []
		for i,prim in enumerate(p.primlst):
			if intersection([c.name for c in prim[0]],HUB) != [] or intersection([c.name for c in prim[1]],HUB) != []:
				inlst.extend(intersection([c.name for c in prim[0]],HUB))
				outlst.extend(intersection([c.name for c in prim[1]],HUB))
				rlst.append(p.rlst[i])
		if rlst != []:
			gp.add_vertices([p.name])
			for h in inlst:
				gp.add_edges([(h,p.name)])
			for h in outlst:
				gp.add_edges([(p.name,h)])
	GO.write_hub_gml(gp,[e for e in dic.elst if intersection([c.name for c in e.cs],HUB) != []],'./results/'+organism+'/graphs/HUB_path_weak_graph.gml')


	


def RegType(dic,organism):
	""" counts and lists the reactions that can be seen as destabilizing or stabilizing (in the sense of reaction and in the sense of pathway)"""
	with open('./results/'+organism+'/logfiles/logstab.log','w') as out:
		out.write('\n\n\n-------------------------------------------------------------------------------------\nDESTABILIZING REACTIONS:\n\n')
		for e in dic.elst:
			destreg = [c.name for c in e.cs if (c in e.rct.inels and e.activation == False) or (c in e.rct.outels and e.activation == True)]
			if len(destreg) != 0:
				out.write('REACTNAME = \t'+e.rct.name+'\nREGULATOR = '+','.join(map(str,destreg))+'\t'+str(e.activation)+'\n\n')
		out.write('\n\n\n-------------------------------------------------------------------------------------\nSTABILIZING REACTIONS:\n\n')
		for e in dic.elst:
			stabreg = [c.name for c in e.cs if (c in e.rct.inels and e.activation == True) or (c in e.rct.outels and e.activation == False)]
			if len(stabreg) != 0:
				out.write('REACTNAME = \t'+e.rct.name+'\nREGULATOR = '+','.join(map(str,stabreg))+'\t'+str(e.activation)+'\n\n')


def PathEnzReg(dic,organism):
	""" lists the 20 couples of pathways with more interactions (activating or inhibing enzymes) """
	#calculation
	ppcorrp = [0] * (len(dic.plst)*len(dic.plst))
	ppcorrn = [0] * (len(dic.plst)*len(dic.plst))
	for e in dic.elst:
		cs = e.cs[0]
		r = e.rct
		if e.activation == None:
			continue
		for (i,p1) in enumerate(dic.plst):
			for (j,p2) in enumerate(dic.plst):
				if cs in p1.sclst and r not in p1.srlst and cs not in p2.sclst and r in p2.srlst and p1 not in p2.splst and p2 not in p1.splst and p1 != p2:
					if e.activation == True:
						ppcorrp[i*len(dic.plst)+j] += 1
					elif e.activation == False:
						ppcorrn[i*len(dic.plst)+j] += 1

	
	#output
	with open('./results/'+organism+'/logfiles/logpath.log','w') as out:
		out.write('#List of the XX couples of most interactive pathways:\n#those pathways that have the biggest number of enzymes (EITHER + OR -) going exclusively from one to the other.\n#FORMAT:\n#number of interactions from p1 to p2 (from p2 to p1) [from p1 to p2 with opposite sign, from p2 to p1 with opposite sign]\n#p1 name \t p2 name\n\nACTIVATION:\n')
		ppcorrtp =  ppcorrp[:]
		ppcorrtn = ppcorrn[:]
		for i in range(20):
			j = ppcorrp.index(max(ppcorrp))
			(m,n) = ((j-j%len(dic.plst))/len(dic.plst),j%len(dic.plst))
			(p1,p2) = (dic.plst[m],dic.plst[n])
			out.write(p1.name+'\t'+p2.name+'\n'+str(ppcorrtp[j])+'\t('+str(ppcorrtp[n*len(dic.plst)+m])+')\t'+str([ppcorrtn[j],ppcorrtn[n*len(dic.plst)+m]])+'\n')
			ppcorrp[m*len(dic.plst)+n] = 0
			ppcorrp[n*len(dic.plst)+m] = 0


		out.write('\n-------------------------------------------------------------------------------------\n\nINHIBITION:\n')
		for i in range(20):
			j = ppcorrn.index(max(ppcorrn))
			(m,n) = ((j-j%len(dic.plst))/len(dic.plst),j%len(dic.plst))
			(p1,p2) = (dic.plst[m],dic.plst[n])
			out.write(p1.name+'\t'+p2.name+'\n'+str(ppcorrtn[j])+'\t('+str(ppcorrtn[n*len(dic.plst)+m])+')\t'+str([ppcorrtp[j],ppcorrtp[n*len(dic.plst)+m]])+'\n')
			ppcorrn[m*len(dic.plst)+n] = 0
			ppcorrn[n*len(dic.plst)+m] = 0

def AXPreg(dic,organism):
	"""
	Finds all the reactions that play a role in AXP conversion (those that are controlled in general, those that are controlled by AXP, and for the latter wether they are stabilizing or destabilizing). 
	The following analysis is then performed:
	- Listing of all enzymatic reactions
	- Listing of all strict futile cycles (those where both reactions are involved in AXP production)
	- Listing of all loose futile cycles (those where only one of the two reactions is involved in AXP production but that share a product and a substrate taken out of a list where compounds have a degree lower than 70% of the maximal one
	- Listing of all very loose futile cycles (those that do not contain an ATP-consuming reaction but that share a product and a substrate taken out of a list where compounds have a degree lower than 70% of the maximal one
)
	"""
	with open('./results/'+organism+'/logfiles/ATPreg.log','w') as out:
		rlst = []
		AXP = ['ATP', 'ADP', 'AMP']
		for r in dic.rlst:
			if intersection(AXP,r.innames) != [] and intersection(AXP,r.outnames) != []:
				rlst.append(r)
		revcount = 0
		contrcount = 0
		cycount = 0
		out.write('CONTROLLED AXP reactions:\n\n')
		for r in rlst:
			if r.reversible == True:
				revcount += 1
			if r.elst != []:
				out.write(r.name+' ['+', '.join(map(str,[p for p in r.inpath]))+']\t'+', '.join(map(str,r.innames))+'\t'+', '.join(map(str,r.outnames))+'\n'+'\n'.join(map(str,[([c.name for c in e.cs],e.activation) for e in r.elst]))+'\n\n')
				contrcount += 1
		out.write('self-controlled AXP reactions (reactions that produce AXP and are controlled by it:\n\n')
		for r in rlst:
			if r.reversible == True:
				revcount += 1
			if r.elst != [] and intersection(AXP,[c.name for c in e.cs]) != []:
				out.write(r.name+' ['+', '.join(map(str,[p for p in r.inpath]))+']\t'+', '.join(map(str,r.innames))+'\t'+', '.join(map(str,r.outnames))+'\n'+'\n'.join(map(str,[([c.name for c in e.cs],e.activation) for e in r.elst]))+'\n\n')
		out.write('---------------------------------------------------------------------------------------\nLOOSE Futile cycles controlled by AXP\n\n')
		filterlst = dic.create_filterlst(int(max(dic.dgraph.degree(dic.dgraph.vs[:]))*0.06))
		for r1 in rlst:
			for r2 in dic.rlst:
				int1 = [c for c in intersection(r1.inels,r2.outels) if c.name not in filterlst]
				int2 = [c for c in intersection(r2.inels,r1.outels) if c.name not in filterlst]
				if len(int1) != 0 and len(int2) != 0 and r1 != r2:
					out.write(r1.name+' ['+', '.join(map(str,[p for p in r1.inpath]))+']\t'+', '.join(map(str,r1.innames))+'\t'+', '.join(map(str,r1.outnames))+'\n')
					out.write(r2.name+' ['+', '.join(map(str,[p for p in r2.inpath]))+']\t'+', '.join(map(str,r2.innames))+'\t'+', '.join(map(str,r2.outnames))+'\nREGULATED-AND:\t'+str(r1.elst != [] or r2.elst != [])+'\nREGULATED-OR:\t'+str(r1.elst != [] and r2.elst != [])+'\n\n')

		out.write('---------------------------------------------------------------------------------------\nSTRICT Futile cycles controlled by AXP\n\n')
		for r1 in rlst:
			for r2 in rlst:
				if len(intersection(r1.inels,r2.outels)) > 1 and len(intersection(r2.inels,r1.outels)) > 1 and r1 != r2:
					out.write(r1.name+' ['+', '.join(map(str,[p for p in r1.inpath]))+']\t'+', '.join(map(str,r1.innames))+'\t'+', '.join(map(str,r1.outnames))+'\n')
					out.write(r2.name+' ['+', '.join(map(str,[p for p in r2.inpath]))+']\t'+', '.join(map(str,r2.innames))+'\t'+', '.join(map(str,r2.outnames))+'\nREGULATED-AND:\t'+str(r1.elst != [] or r2.elst != [])+'\nREGULATED-OR:\t'+str(r1.elst != [] and r2.elst != [])+'\n\n')
		print 'very long one'
		out.write('---------------------------------------------------------------------------------------\nVERY LOOSE Futile cycles controlled by AXP\n\n')
		for r1 in dic.rlst:
			for r2 in dic.rlst:
				int1 = [c for c in intersection(r1.inels,r2.outels) if c.name not in filterlst]
				int2 = [c for c in intersection(r2.inels,r1.outels) if c.name not in filterlst]
				if len(int1) != 0 and len(int2) != 0 and r1 != r2:
					cycount += 1
					out.write(r1.name+' ['+', '.join(map(str,[p for p in r1.inpath]))+']\t'+', '.join(map(str,r1.innames))+'\t'+', '.join(map(str,r1.outnames))+'\n')
					out.write(r2.name+' ['+', '.join(map(str,[p for p in r2.inpath]))+']\t'+', '.join(map(str,r2.innames))+'\t'+', '.join(map(str,r2.outnames))+'\nREGULATED-AND:\t'+str(r1.elst != [] or r2.elst != [])+'\nREGULATED-OR:\t'+str(r1.elst != [] and r2.elst != [])+'\n\n')

		print('% of REVERSIBLE AXP-converting reactions:\t'+str(revcount)+' out of '+str(len(rlst)))
		print('% of CONTROLLED AXP-converting reactions:\t'+str(contrcount)+' out of '+str(len(rlst)))
		print('# of cycles:\t'+str(cycount))

def XMotifSearch(dic,organism):
	""" Research of X motifs in the graph (XOR and AND gates) """
	tolst = []
	fromlst = []
	XORlst = [0]*dic.dgraph.vcount()
	indlst = dic.dgraph.degree(mode=IN)
	outdlst = dic.dgraph.degree(mode=OUT)
	for i,vn in enumerate(dic.dgraph.vs['name']):
		if indlst[i] == 2 and 'RXN' not in vn:
			tolst.append(i)
		if outdlst[i] == 2 and 'RXN' not in vn:
			fromlst.append(i)

	with open('./results/'+organism+'/logfiles/XORMotifs.log','w') as out:
		out.write('#List of STRICT XOR motifs i.e., those motifs that have only two reactions connecting them\n#in one sense and n reactions connecting them in the other an no other inflow ot outflow reaction\n#Structure:\tcomp. from\tcomp. to\n#rct1\tinpathlst\n#rct2\tinpathlst\n')

		for i in tolst:
			for j in fromlst:
				if sorted(dic.dgraph.neighborhood(i,order=1,mode=IN)) == sorted(dic.dgraph.neighborhood(j,order=1,mode=OUT)) and dic.dgraph.neighborhood(i,order=1,mode=IN) != [] and sorted(dic.dgraph.neighborhood(i,order=1,mode=OUT)) == sorted(dic.dgraph.neighborhood(j,order=1,mode=IN)):
					XORlst[i] = 1
					XORlst[j] = 1
					XORrlst = dic.dgraph.neighborhood(i,order=1,mode=OUT) 
					for k in XORrlst:
						XORlst[k] = 1
						r1 = dic.rsearch(dic.dgraph.vs['name'][XORrlst[1]])
						r2 = dic.rsearch(dic.dgraph.vs['name'][XORrlst[2]])
						if r1 != None and r2 != None:
							out.write(dic.dgraph.vs['name'][i]+'\t'+dic.dgraph.vs['name'][i]+'\n'+r1.name+'\t'+', '.join(map(str,r1.inpath))+'\n'+r2.name+'\t'+', '.join(map(str,r2.inpath))+'\n\n')
						

	dic.dgraph.vs['XOR'] = XORlst
			
def intersection(a,b):
	lst = []
	for i in a:
		if i in b:
			lst.append(i)
	return lst


def ExportGraphs(dic,organism):
			
	for p1 in dic.plst:
		if p1.name in ['GLYCOLYSIS-E-D', 'GLYCOLYSIS', 'GLYCOLYSIS-TCA-GLYOX-BYPASS']:
			totgraphname = './results/'+organism+'/'+p1.name+'_tot.gml'
			primgraphname = './results/'+organism+'/'+p1.name+'_prim.gml'
			GO.write_pathway_gml(p1.totgraph,p1.elst,totgraphname)
			p1.primgraph.write_gml(primgraphname)

			for p2 in dic.plst:
				if p2.name in ['GLUCONEO-PWY','FERMENTATION-PWY','HEXITOLDEGSUPER-PWY','FAO-PWY','PWY0-1337','PENTOSE-P-PWY','TREDEGLOW-PWY']:
					mergedname = './results/'+organism+'/graphs/'+p1.name+'+'+p2.name+'_tot.gml'
					GO.write_pathway_gml(EC.merge(p1.totgraph,p2.totgraph),list(set(p1.elst[:]+p2.elst[:])),mergedname)

def ExportDGraph(dic,organism):
	adjlst = dic.dgraph.get_adjlist()
	vnlst = dic.dgraph.vs['name'][:]
	
	with open('./results/'+organism+'/graphs/adjlst.txt','w') as adjf:
		adjf.write('#adjlst file: this file contains the adjacency list of the metabolic graph of the organism '+organism+'.\n#The n-th line of this file contains the list of OUT-neighbours of the n-th vertex of the graph.\n#List of names corresponding to each vertex is contained in the file "vnlst.txt" in this folder.\n')
		for l in adjlst:
			adjf.write(', '.join(map(str,l))+'\n')
			
	with open('./results/'+organism+'/graphs/vnlst.txt','w') as vnf:
		vnf.write('#vnlst file: this file contains the list of names of the metabolites and reactions of the organism '+organism+'.\n#The n-th line of this file contains the name associated to the n-th node of the graph whose adjacency list is stored in the file adjlst.txt in the same folder.\n')
		for l in vnlst:
			vnf.write(str(l)+'\n')


if __name__ == "__main__":
	organism = raw_input('Organism? (ecoli/yeast[custom]) \n')
	if organism == 'y':
		organism = 'yeast'
	if organism == 'e':
		organism = 'ecoli'
	if organism == 'm':
		organism = 'mus'
	dic = EC.ReactDic(organism)
	EL.decode(organism,dic)

	ExportDGraph(dic,organism)
	print dic.dgraph.summary()

	alldo = False
	if raw_input('all? [y/n] ') == 'y':
		alldo = True

	deglst = [(dic.dgraph.degree(i, mode = ALL),n) for i,n in enumerate(dic.dgraph.vs['name'][:]) if 'RXN' not in n]
	deglst.sort()
	with open('./results/'+organism+'/logfiles/Degreelis.log','w') as out:
		out.write('List of degrees of compound nodes\n\n'+'\n'.join([str(deglst[i][0])+'\t'+deglst[i][1] for i in range(len(deglst))]))

	FbReg(dic,organism)

	if alldo or raw_input('STOICH analysis? [y/n] ') == 'y':
		stoich(dic,organism)

	if alldo or raw_input('HUB analysis? [y/n] ') == 'y':
		HubAnalysis(dic,organism)
		print '\nHubAnalysis:\tdone'

	if alldo or raw_input('Export graphs of energetic pathways? [y/n] ') == 'y':
		ExportGraphs(dic,organism)
		print '\nExportGraphs:\tdone'

	if alldo or raw_input('List of multiregulated reactions? [y/n] ') == 'y':
		DoubleReg(dic,organism)
		print '\nDoubleReg:\tdone'

	if alldo or raw_input('List of destabilizing reactions [y/n] ') == 'y':
		RegType(dic,organism)
		print 'RegType:\tdone'

	if alldo or raw_input('AXP analysis? [y/n] ') == 'y':
		AXPreg(dic,organism)
		print 'AXPreg:\tdone'

	if alldo or raw_input('List of most interactive pathways? [y/n] ') == 'y':
		PathEnzReg(dic,organism)
		print 'PathEnzReg:\tdone'

	if alldo or raw_input('Search for XOR motifs? [y/n] ') == 'y':
		XMotifSearch(dic,organism)
		print 'XORMotifSearch:\tdone'
	
	dic.dgraph.write_gml('./results/totgraph.gml')



	print('Graph drawing:\tdone')
	
	for m in dic.mlst:
		print 'motif'
		print m.graph

	print('\nProgram executed correctly.')


